type USER {
  idUser: ID!
  nickname: String!
  name: String!
  lastName: String!
  phoneNumber: Int
  birthDate: String!
  email: String!
  gender: String!
  emailNotifications: Boolean!
  picturePath: String
  purpose: String
  friends: [is_friend!]
  owns: FcgToUser
  observing: FcgShareTo
  fcg: [FCGroup] @cypher (
    statement: "MATCH (this)-[:OWNS_FCG]->(f:FCGroup) RETURN f"
  )
  observing_fcgs: [FCGroup] @cypher (
    statement: "MATCH (this)-[:IS_OBSERVING_FCG {posible:0}]->(f:FCGroup) RETURN f"
  )
}

type FC {
  idFc: ID!
  front: String!
  back: String!
  lastModifyDate: String!
  creationDate: String!
  comments: String
  contatins: FcToFcg
  idFCG: String!
}

type FCGroup {
  idFcg: ID!
  idUser: String!
  idCat: String!
  idScat: String!
  title: String!
  retentive: Float
  public: Boolean!
  isStudying: Boolean!
  lastModifyDate: String!
  creationDate: String!
  specificTags: [String!]
  remainingNotifications: Int
  fc: [FC] @cypher (
    statement: "MATCH (this)-[:CONTAINS_FC]->(f:FC) RETURN f"
  )
  observing_users: [USER] @cypher (
    statement: "MATCH (this)<-[r:IS_OBSERVING_FCG]-(u:USER) RETURN u"
  )
}

type CAT{
  id: ID!
  name: String!
  fcg: [FCGroup] @cypher (
    statement: "MATCH (this)-[:CONTAINS_FCG]->(f:FCGroup) RETURN f"
  )
}

type SCAT{
  id: ID!
  name: String!
  commonTags: [String!]


}

type Fifi{
  idFcgDel: ID!
}

type Fifi2{
  idFcDel: ID!
}

##RELATIONSHIPS

type is_friend @relation(name: "IS_FRIEND") {
    from: USER!
    to: USER!
    notifications: Boolean!
}

type FcgToUser @relation(name: "OWNS_FCG"){
  from: USER
  to: FCGroup
}
type FcToFcg @relation(name: "CONTAINS_FC"){
  from: FCGroup
  to: FC
}
type  FcgShareTo @relation(name: "IS_OBSERVING_FCG"){
  from: USER
  to: FCGroup
}

